<!DOCTYPE HTML/><html lang="en-US"><head><script type="text/javascript">if (window.location.host === 'mliezun.github.io') {
                    window.location.host = 'mliezun.com';
                }
</script><meta charset="UTF-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Writing a Redis clone in Go from scratch</title><meta name="generator" content="Custom"/><meta property="og:title" content="Writing a Redis clone in Go from scratch"/><meta property="og:locale" content="en_US"/><meta name="description" content="In this post we're going to write a basic Redis clone in Go that implements the most simple commands: GET, 
SET, DEL and QUIT. At the end you'll know how to parse a byte stream from a live TCP connection, and hopefully have a working
implementation of Redis."/><meta property="og:description" content="In this post we're going to write a basic Redis clone in Go that implements the most simple commands: GET, 
SET, DEL and QUIT. At the end you'll know how to parse a byte stream from a live TCP connection, and hopefully have a working
implementation of Redis."/><meta name="keywords" content="programming,go,redis,diy,golang"/><link rel="canonical" href="https://mliezun.com/2023/04/08/redis-clone.html"/><meta property="og:url" content="https://mliezun.com/2023/04/08/redis-clone.html"/><meta property="og:site_name" content="mliezun.com"/><meta property="og:image" content="https://mliezun.com/assets/images/nyc.jpg"/><link rel="icon" type="image/x-icon" href="/assets/images/favicon.ico"/><meta property="og:type" content="article"/><meta name="twitter:card" content="summary"/><meta property="twitter:title" content="Writing a Redis clone in Go from scratch"/><meta name="twitter:creator" content="@migueliezun"/><meta name="twitter:image" content="https://mliezun.com/assets/images/nyc.jpg"/>
<script type="application/ld+json">{"description":"In this post we're going to write a basic Redis clone in Go that implements the most simple commands: GET, 
SET, DEL and QUIT. At the end you'll know how to parse a byte stream from a live TCP connection, and hopefully have a working
implementation of Redis.","author":{"@type":"Person","name":"Miguel Liezun"},"@type":"BlogPosting","url":"https://mliezun.com/2023/04/08/redis-clone.html","headline":"Writing a Redis clone in Go from scratch","dateModified":"2023-04-08T00:00:00-03:00","datePublished":"2023-04-08T00:00:00-03:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mliezun.com/2023/04/08/redis-clone.html"},"@context":"https://schema.org"}
</script><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin=""/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap"/><link rel="stylesheet" href="/assets/css/style.css"/></head><body><div class="body-wrapper"><div class="body-content"><div class="site-header"><header><a href="/" style="text-decoration: none !important">Miguel's dev blog</a></header><button class="theme-toggle" id="theme-toggle" title="Toggle theme"><img src="/assets/images/circle-half.svg"/></button></div><hr/><article><h2>Writing a Redis clone in Go from scratch</h2><p>In this post we're going to write a basic Redis clone in Go that implements the most simple commands: GET, 
SET, DEL and QUIT. At the end you'll know how to parse a byte stream from a live TCP connection, and hopefully have a working
implementation of Redis.</p><p>What's intersting about this project is that it's <em>production ready</em> (not really).
		It's being used in production in an old Web app that I made for a client in 2017. 
		<strong>It has been running for a few months now without issues</strong>.</p><p>I mantain that app to this day and I charge like 50 bucks a month for it. I do it because
		Im friends with the person that uses the app.</p><p>Long story short, the app's backend is written in PHP and uses Redis for caching, only GET, SET and DEL commands. 
		I asked my friend if I could replace it with my custom version and said yes, so I decided to give it a go.</p><p>If you're looking for C/C++ implementation, go check out this <a href='https://build-your-own.org/redis/' target='_blank'>book</a>.</p><h3>What we'll be building</h3><p>If you go to the 
<a href="https://redis.io/commands/" target="_blank">command list</a> on redis webpage you'll see that there are 463 commands to this day (maybe more if you're in the future).
</p><p>That's a crazy number. Here, we're only implementing 4 commands: <span class="single-quote language-undefined">GET, SET, DEL, QUIT</span>,
 <em>the other 459 commands are left as an exercise to the reader</em>.
</p><h4>GET</h4><p><pre class="triple-quote redis language-css">GET key
</pre></p><p>Returns the value referenced by <span class="single-quote language-undefined">key</span>.
 If the key does not exist then <span class="single-quote language-undefined">nil</span> is returned.
</p><h4>SET</h4><p>SET command gains more features on newer versions of Redis. We're going to implement one that has all features
 that were realeased up until version 6.0.0.
</p><p><pre class="triple-quote redis">SET key value [NX | XX] [EX seconds | PX milliseconds]
</pre></p><p>Stores <span class="single-quote language-undefined">value</span> as a string that is referenced by <span class="single-quote language-undefined">key</span>.
 Overwrites any data that was previously referenced by the key.
</p><h5>Options</h5><p><ul><li><span class="single-quote">EX</span> <em>seconds</em> -- Set the specified expire time, in seconds.</li><li><span class="single-quote">PX</span> <em>milliseconds</em> -- Set the specified expire time, in seconds.</li><li><span class="single-quote">NX</span> <em></em> -- Only set the key if it does not already exist.</li><li><span class="single-quote">XX</span> <em></em> -- Only set the key if it already exist.</li></ul></p><h4>DEL</h4><p><pre class="triple-quote redis">DEL key [key ...]
</pre></p><p>Takes 'any' amount of keys as input and removes all of them from storage. If a key doesn't exist it is ignored.
 Returns the amount of keys that were deleted.
</p><h4>QUIT</h4><p><pre class="triple-quote redis">QUIT
</pre></p><p>When receiving this command the server closes the connection. It's useful for interactive sessions.
 For production environments the client should close the connection without sending any commands.
</p><h4>Examples</h4><p>Let's start an interactive session of redis to test some commands.
 We can install redis-server with docker and run it locally.
 Then we can use telnet to connect directly via TCP.
 Open a terminal and execute the following instructions:
</p><p><pre class="triple-quote bash">$ docker run -d --name redis-server -p 6379:6379 redis:alpine

$ telnet 127.0.0.1 6379
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
</pre></p><p>At this point the prompt should be waiting for you to write something. We're gonna test a couple of commands.
 In the code boxes below the first line is the command, following lines are the response.
</p><p><pre class="triple-quote redis language-css">GET a
$-1
</pre>^ That weird $-1 is the special <em>nil</em> value. Which means there's nothing stored here.
</p><p><pre class="triple-quote redis language-css">set a 1
+OK
</pre>^ First thing to notice here is that we can use lowercase version of SET.
 Also, when the command is successful returns +OK.
</p><p><pre class="triple-quote redis language-css">set b 2
+OK
</pre></p><p><pre class="triple-quote redis language-css">SET c 3
+OK
</pre>^ Just storing a couple more values.
</p><p><pre class="triple-quote redis language-css">GET a
$1
1
</pre>^ Here the response is returned in two lines. First line is the length of the string. Second line
 is the actual string.
</p><p><pre class="triple-quote redis language-css">get b
$1
2
</pre>^ We can also use lowercase version of GET, I bet commands are case-insensitive.
</p><p><pre class="triple-quote redis language-css">get C
$-1
</pre>^ Testing with uppercase C gives a <em>nil</em>. Keys seem to be case-sensitive, probably values too.
 That makes sense.
</p><p><pre class="triple-quote redis language-css">del a b c
:3
</pre>^ Deleting everything returns the amount of keys deleted. Integers are indicated by ':'.
</p><p><pre class="triple-quote redis language-css">quit
+OK
Connection closed by foreign host.
</pre>^ When we send QUIT, the server closes the connection and we're back to our terminal session.
</p><p>With those tests we have enough information to start building. We learned a little bit about the
 redis protocol and what the responses look like.
</p><h4>Sending commands</h4><p>Until now we've been using the <em>inline</em> version of redis command.
 There's another kind that follows the 
<a href="https://redis.io/docs/reference/protocol-spec/" target="_blank">RESP (Redis serialization protocol).</a></p><p>The RESP protocol is quite similar to what we've seen in the examples above.
The most important addition is <em>arrays</em>. Let's see a Client<>Server interaction
 using arrays.
</p><p><strong>Client</strong><pre class="triple-quote redis language-css">*2
$3
GET
$1
a
</pre><strong>Server</strong><pre class="triple-quote redis language-css">$-1
</pre>The server response looks the same as in the inline version.
 But what the client sends looks very different:
</p><ul><li>In this case, the first thing the client sends is '*' followed by the number of elements in the array,
 so '*2' indicates that there are 2 elements in the array and they would be found in the following lines.
</li><li>After that we have '$3' which means we're expecting the first element to be a string of length 3.
 Next line is the actual string, in our case is the command 'GET'.
</li><li>The next value is also a string and is the key passed to the command.
</li></ul><p>That's almost everything we need to start building a client. There's one last thing: <strong>error responses</strong>.
<pre class="triple-quote redis language-css">-Example error message
-ERR unknown command 'foo'
-WRONGTYPE Operation against a key holding the wrong kind of value
</pre>A response that starts with a '-' is considered an error. The first word is the error type.
 We'll only gonna be using 'ERR' as a generic response.
</p><p>RESP protocol is what client libraries use to communicate with Redis.
 With all that in our toolbox we're ready to start building.
</p><h3>Receiving connections</h3><p>A crucial part of our serve is the ability to receive client's information.
 The way that this is done is that the server listens on a TCP port and waits
 for client connections. Let's start building the basic structure.
</p><p>Create a new go module, open main.go and create a main function as follows.
</p><pre class="triple-quote go language-go">package main

import (
	"bufio"
	"fmt"
	"log"
	"net"
	"strconv"
	"strings"
	"sync"
	"time"
)

var cache sync.Map

func main() {
	listener, err := net.Listen("tcp", ":6380")
	if err != nil {
		log.Fatal(err)
	}
	log.Println("Listening on tcp://0.0.0.0:6380")

	for {
		conn, err := listener.Accept()
		log.Println("New connection", conn)
		if err != nil {
			log.Fatal(err)
		}

		go startSession(conn)
	}
}
</pre><p>After declaring the package and imports, we create a global sync.Map that would be our cache.
 That's where keys are gonna be stored and retrieved.
</p><p>On the main function we start listening on port 6380. After that we have an infinite loop that accepts
 new connections and spawns a goroutine to handle the session.
</p><h4>Session handling</h4><pre class="triple-quote go language-go">// startSession handles the client's session. Parses and executes commands and writes
// responses back to the client.
func startSession(conn net.Conn) {
	defer func() {
		log.Println("Closing connection", conn)
		conn.Close()
	}()
	defer func() {
		if err := recover(); err != nil {
			log.Println("Recovering from error", err)
		}
	}()
	p := NewParser(conn)
	for {
		cmd, err := p.command()
		if err != nil {
			log.Println("Error", err)
			conn.Write([]uint8("-ERR " + err.Error() + "\r\n"))
			break
		}
		if !cmd.handle() {
			break
		}
	}
}
</pre><p>It's super important that we close the connection when things are done. That's why we set a deferred function,
 to close the connection when the session finishes.
</p><p>After that we handle any panics using recover. We do this mainly because at some point we might be reading from
 a connection that was closed by the client. And we don't want the entire server to die in case of an error.
</p><p>Then we create a new parser and start trying to parse commands from the live connection. If we encounter an error
 we write the error message back to the client and we finish the session.
</p><p>When cmd.handle() returns false (signaling end of session) we break the loop and the session finishes.
</p><h3>Parsing commands</h3><p>Basic parser structure:
</p><pre class="triple-quote go language-go">// Parser contains the logic to read from a raw tcp connection and parse commands.
type Parser struct {
	conn net.Conn
	r    *bufio.Reader
	// Used for inline parsing
	line []byte
	pos  int
}

// NewParser returns a new Parser that reads from the given connection.
func NewParser(conn net.Conn) *Parser {
	return &amp;Parser{
		conn: conn,
		r:    bufio.NewReader(conn),
		line: make([]byte, 0),
		pos:  0,
	}
}
</pre><p>This is pretty straight-forward. We store a reference to the connection, a reader and then some
 attributes that will help us with parsing.
</p><p>The NewParser() function should be used as a contructor for Parser objects.
</p><p>We need some helper functions that will make parsing easier:
</p><pre class="triple-quote go language-go">func (p *Parser) current() byte {
	if p.atEnd() {
		return '\r'
	}
	return p.line[p.pos]
}

func (p *Parser) advance() {
	p.pos++
}

func (p *Parser) atEnd() bool {
	return p.pos >= len(p.line)
}

func (p *Parser) readLine() ([]byte, error) {
	line, err := p.r.ReadBytes('\r')
	if err != nil {
		return nil, err
	}
	if _, err := p.r.ReadByte(); err != nil {
		return nil, err
	}
	return line[:len(line)-1], nil
}
</pre><p>Also quite simple.
<ul><li>current(): Returns the character being pointed at by pos inside the line.</li><li>advance(): Point to the next character in the line.</li><li>atEnd(): Indicates if we're at the end of the line.</li><li>readLine(): Reads the input from the connection up to the carriage return char. Skips the '\n' char.</li></ul></p><h4>Parsing strings</h4><p>In Redis we can send commands like so:
</p><pre class="triple-quote redis language-css">SET text "quoted \"text\" here"
</pre><p>This means we need a way to handle \, " chars inside a string.
</p><p>For that we need a special parsing function that will handle strings:
</p><pre class="triple-quote go language-go">// consumeString reads a string argument from the current line.
func (p *Parser) consumeString() (s []byte, err error) {
	for p.current() != '"' &amp;&amp; !p.atEnd() {
		cur := p.current()
		p.advance()
		next := p.current()
		if cur == '\\' &amp;&amp; next == '"' {
			s = append(s, '"')
			p.advance()
		} else {
			s = append(s, cur)
		}
	}
	if p.current() != '"' {
		return nil, errors.New("unbalanced quotes in request")
	}
	p.advance()
	return
}
</pre><p>From the functions that we've declared up to this point it's pretty clear that our parser
 will be reading the input line by line. And the consuming the line one char at a time.
</p><p>The way consumeString() works is quite tricky.
 It assumes that the initial " has been consumed before entering the function.
 And it consumes all characters in the current line up until it reaches the closing quotes character
 or the end of the line.
</p><p>Inside the loop we can see that we're reading the current character and advancing the pointer, then
 the next character.
 When the user is sending an escaped quote inside the string we detect that by checking the current
 and the next characters.
 In this special case we end up advancing the pointer twice. Because we consumed two: chars the backslash
 and the quote. But we added only one char to the output: ".
</p><p>We append all other characters to the output buffer.
</p><p>When the loop finishes, if we're not pointing to the end quote char, that means that the user
 sent an invalid command and we return an error.
</p><p>Otherwise we advance the pointer and return normally.
</p><h4>Parsing commands</h4><pre class="triple-quote go language-go">// command parses and returns a Command.
func (p *Parser) command() (Command, error) {
	b, err := p.r.ReadByte()
	if err != nil {
		return Command{}, err
	}
	if b == '*' {
		log.Println("resp array")
		return p.respArray()
	} else {
		line, err := p.readLine()
		if err != nil {
			return Command{}, err
		}
		p.pos = 0
		p.line = append([]byte{}, b)
		p.line = append(p.line, line...)
		return p.inline()
	}
}
</pre><p>We read the first character sent by the client. If it's an asterisk we handle it
 using the RESP protocol. Otherwise we assume that it's an inline command.
</p><p>Let's start by parsing the inline commands first.
</p><pre class="triple-quote go language-go">// Command implements the behavior of the commands.
type Command struct {
	args []string
	conn net.Conn
}

// inline parses an inline message and returns a Command. Returns an error when there's
// a problem reading from the connection or parsing the command.
func (p *Parser) inline() (Command, error) {
	// skip initial whitespace if any
	for p.current() == ' ' {
		p.advance()
	}
	cmd := Command{conn: p.conn}
	for !p.atEnd() {
		arg, err := p.consumeArg()
		if err != nil {
			return cmd, err
		}
		if arg != "" {
			cmd.args = append(cmd.args, arg)
		}
	}
	return cmd, nil
}
</pre><p>This is also quite easy to skim through. We skip any leading whitespace
 in case the user sent something like '     GET a'.
</p><p>We create a new Command object with a reference to the session connection.
</p><p>While we're not at the end of the line we consume args and append them to the
 arg list of the command object if they are not empty.
</p><p><strong>Consuming arguments</strong></p><pre class="triple-quote go language-go">// consumeArg reads an argument from the current line.
func (p *Parser) consumeArg() (s string, err error) {
	for p.current() == ' ' {
		p.advance()
	}
	if p.current() == '"' {
		p.advance()
		buf, err := p.consumeString()
		return string(buf), err
	}
	for !p.atEnd() &amp;&amp; p.current() != ' ' &amp;&amp; p.current() != '\r' {
		s += string(p.current())
		p.advance()
	}
	return
}
</pre><p>Same as before we consume any leading whitespace.
</p><p>If we find a quoted string we call our function from before: consumeString().
</p><p>We append all characters to the output until we reach a carriage return \r, a whitespace
 or the end of the line.
</p><h4>Parsing RESP protocol</h4><pre class="triple-quote go language-go">// respArray parses a RESP array and returns a Command. Returns an error when there's
// a problem reading from the connection.
func (p *Parser) respArray() (Command, error) {
	cmd := Command{}
	elementsStr, err := p.readLine()
	if err != nil {
		return cmd, err
	}
	elements, _ := strconv.Atoi(string(elementsStr))
	log.Println("Elements", elements)
	for i := 0; i < elements; i++ {
		tp, err := p.r.ReadByte()
		if err != nil {
			return cmd, err
		}
		switch tp {
		case ':':
			arg, err := p.readLine()
			if err != nil {
				return cmd, err
			}
			cmd.args = append(cmd.args, string(arg))
		case '$':
			arg, err := p.readLine()
			if err != nil {
				return cmd, err
			}
			length, _ := strconv.Atoi(string(arg))
			text := make([]byte, 0)
			for i := 0; len(text) <= length; i++ {
				line, err := p.readLine()
				if err != nil {
					return cmd, err
				}
				text = append(text, line...)
			}
			cmd.args = append(cmd.args, string(text[:length]))
		case '*':
			next, err := p.respArray()
			if err != nil {
				return cmd, err
			}
			cmd.args = append(cmd.args, next.args...)
		}
	}
	return cmd, nil
}
</pre><p>As we know, the leading asterisk has already been consumed from the connection input.
 So, at this point, the first line contains the number of elements to be consumed.
 We read that into an integer.
</p><p>We create a for loop with that will parse all the elements in the array.
 We consume the first character to detect which kind of element we need to consume: int, string or array.
</p><p>The int case is quite simple, we just read until the rest of the line.
</p><p>The array case is also quite simple, we call respArray() and append the args of the result,
 to the current command object.
</p><p>For strings we read the first line and get the size of the string.
 We keep reading lines until we have read the indicated amount of characters.
</p><h3>Handling commands</h3><p>This is the 'fun' part of the implementation. Were our server becomes alive.
 In this section we'll implement the actual functionality of the commands.
</p><p>Let's start with the cmd.handle() function that we saw in handleSession().
</p><pre class="triple-quote go language-go">// handle Executes the command and writes the response. Returns false when the connection should be closed.
func (cmd Command) handle() bool {
	switch strings.ToUpper(cmd.args[0]) {
	case "GET":
		return cmd.get()
	case "SET":
		return cmd.set()
	case "DEL":
		return cmd.del()
	case "QUIT":
		return cmd.quit()
	default:
		log.Println("Command not supported", cmd.args[0])
		cmd.conn.Write([]uint8("-ERR unknown command '" + cmd.args[0] + "'\r\n"))
	}
	return true
}
</pre><p>Needs no further explanation. Let's implement the easiest command: QUIT.
</p><pre class="triple-quote go language-go">// quit Used in interactive/inline mode, instructs the server to terminate the connection.
func (cmd *Command) quit() bool {
	if len(cmd.args) != 1 {
		cmd.conn.Write([]uint8("-ERR wrong number of arguments for '" + cmd.args[0] + "' command\r\n"))
		return true
	}
	log.Println("Handle QUIT")
	cmd.conn.Write([]uint8("+OK\r\n"))
	return false
}
</pre><p>If any extra arguments were passed to QUIT, it returns an error.
</p><p>Otherwise write +OK to the client and return false.
 Which if you remember handleSession() is the value to indicate that the session has finished.
 After that the connection will be automatically closed.
</p><p>The next easieast command is DEL
</p><pre class="triple-quote go language-go">// del Deletes a key from the cache.
func (cmd *Command) del() bool {
	count := 0
	for _, k := range cmd.args[1:] {
		if _, ok := cache.LoadAndDelete(k); ok {
			count++
		}
	}
	cmd.conn.Write([]uint8(fmt.Sprintf(":%d\r\n", count)))
	return true
}
</pre><p>Iterates through all the keys passed, deletes the ones that exists and
 writes back to the client the amount of keys deleted.
</p><p>Returns true, which means the connection is kept alive.
</p><h4>Handling GET</h4><pre class="triple-quote go language-go">// get Fetches a key from the cache if exists.
func (cmd Command) get() bool {
	if len(cmd.args) != 2 {
		cmd.conn.Write([]uint8("-ERR wrong number of arguments for '" + cmd.args[0] + "' command\r\n"))
		return true
	}
	log.Println("Handle GET")
	val, _ := cache.Load(cmd.args[1])
	if val != nil {
		res, _ := val.(string)
		if strings.HasPrefix(res, "\"") {
			res, _ = strconv.Unquote(res)
		}
		log.Println("Response length", len(res))
		cmd.conn.Write([]uint8(fmt.Sprintf("$%d\r\n", len(res))))
		cmd.conn.Write(append([]uint8(res), []uint8("\r\n")...))
	} else {
		cmd.conn.Write([]uint8("$-1\r\n"))
	}
	return true
}
</pre><p>As before, we validate that the correct number of arguments were passed to the command.
</p><p>We load the value from the global variable cache.
</p><p>If the value is nil we write back to the client the special $-1.
</p><p>When we have a value we cast it as string and unquote it in case it's quoted.
 Then we write the length as the first line of the response and the string as the
 second line of the response.
</p><h4>Handling SET</h4><p>This is the most complicated command that we'll implement.
</p><pre class="triple-quote go language-go">// set Stores a key and value on the cache. Optionally sets expiration on the key.
func (cmd Command) set() bool {
	if len(cmd.args) < 3 || len(cmd.args) > 6 {
		cmd.conn.Write([]uint8("-ERR wrong number of arguments for '" + cmd.args[0] + "' command\r\n"))
		return true
	}
	log.Println("Handle SET")
	log.Println("Value length", len(cmd.args[2]))
	if len(cmd.args) > 3 {
		pos := 3
		option := strings.ToUpper(cmd.args[pos])
		switch option {
		case "NX":
			log.Println("Handle NX")
			if _, ok := cache.Load(cmd.args[1]); ok {
				cmd.conn.Write([]uint8("$-1\r\n"))
				return true
			}
			pos++
		case "XX":
			log.Println("Handle XX")
			if _, ok := cache.Load(cmd.args[1]); !ok {
				cmd.conn.Write([]uint8("$-1\r\n"))
				return true
			}
			pos++
		}
		if len(cmd.args) > pos {
			if err := cmd.setExpiration(pos); err != nil {
				cmd.conn.Write([]uint8("-ERR " + err.Error() + "\r\n"))
				return true
			}
		}
	}
	cache.Store(cmd.args[1], cmd.args[2])
	cmd.conn.Write([]uint8("+OK\r\n"))
	return true
}
</pre><p>As always, first thing we do is validate the number of arguments.
 But in this case, SET is more tricky than the others.
</p><p>When more than 3 arguments are passed we check for the NX or XX flags and handle them accordingly.
</p><ul><li><span class="single-quote">NX</span> <em></em> -- Only set the key if it does not already exist.</li><li><span class="single-quote">XX</span> <em></em> -- Only set the key if it already exist.</li></ul><p>Then we parse the expiration flags if any. We'll see how that's done in a second.
</p><p>After handling all those special cases we finally store the key and value in the cache,
 write the +OK response and return true to keep the connection alive.
</p><p><strong>Expiration</strong></p><pre class="triple-quote go language-go">// setExpiration Handles expiration when passed as part of the 'set' command.
func (cmd Command) setExpiration(pos int) error {
	option := strings.ToUpper(cmd.args[pos])
	value, _ := strconv.Atoi(cmd.args[pos+1])
	var duration time.Duration
	switch option {
	case "EX":
		duration = time.Second * time.Duration(value)
	case "PX":
		duration = time.Millisecond * time.Duration(value)
	default:
		return fmt.Errorf("expiration option is not valid")
	}
	go func() {
		log.Printf("Handling '%s', sleeping for %v\n", option, duration)
		time.Sleep(duration)
		cache.Delete(cmd.args[1])
	}()
	return nil
}
</pre><p>We read the option and the expiration value, then we compute the duration
 for each case and we spawn a new goroutine that sleeps for that amount of
 time and the deletes the key from the cache.
</p><p>This is not the most efficient way to do it, but it's simple and it works for us.
</p><h2>Working server</h2><p>At this point we have an usable implementation of Redis.
</p><p>Let's start the server the server and test it.
</p><pre class="triple-quote redis language-css">$ go run main.go
2023/04/08 21:09:40 Listening on tcp://0.0.0.0:6380
</pre><p>On a different terminal connect to the server.
</p><pre class="triple-quote redis language-css">$ telnet 127.0.0.1 6380
GET a
$-1
set a "test \"quotes\" are working"
+OK
get a
$25
test "quotes" are working
</pre><p>It's alive!! Go have fun.
</p><p>If you'd like to access the source code of this project there's a public gist
 containing all of the code displayed here.
</p><p><a href="https://gist.github.com/mliezun/f55baa4cd024c1cdf3030e49c5f87875" target="_blank">Link to source code</a></p></article><footer><hr/><div class="footer-wrapper"><div><div>This blog was made with 
<a target="_blank" href="https://github.com/mliezun/grotsky">Grotsky</a></div><div>Blog
<a target="_blank" href="https://github.com/mliezun/mliezun.com">source code</a></div></div><div class="footer-socials"><a target="_blank" href="https://mliezun.com/feed.xml"><img alt="RSS Feed" src="/assets/images/socials/rss.png" width="20" height="20" style="border-radius: 3px"/></a><a target="_blank" href="https://github.com/mliezun"><img alt="Github" src="/assets/images/socials/github.png" width="20" height="20"/></a><a target="_blank" href="https://x.com/migueliezun"><img alt="X (Twitter)" src="/assets/images/socials/x.ico" width="20" height="20" style="border-radius: 5px"/></a><a target="_blank" href="https://www.linkedin.com/in/miguel-liezun-8697a9168/"><img alt="LinkedIn" src="/assets/images/socials/linkedin.png" width="20" height="20"/></a></div></div></footer></div></div><script src="/assets/js/theme-switcher.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/atom-one-dark.min.css"/><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script><script>document.querySelectorAll('.triple-quote').forEach(function (el) {
                    if (el.classList.length > 1) hljs.highlightElement(el, {language: el.classList[1]});
                    else hljs.highlightElement(el);
                    el.classList.remove('hljs');
                })
</script><script>document.querySelectorAll('.single-quote').forEach(function (el) {
                    if (el.classList.length > 1) hljs.highlightElement(el, {language: el.classList[1]});
                    else hljs.highlightElement(el);
                    el.classList.remove('hljs');
                })
</script></body></html>