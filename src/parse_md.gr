let u = import("./utils.gr")


fn parseHeader(content) {
	let content = u.splitlines(content)
	let start = u.find(content, "---")
	let end = u.find(content[start+1:], "---")
	let headers = {}
	for l in content[start+1:end+1] {
		let config = u.split(l, ":")
		let attr = u.trimchar(
			u.trimspaces(config[0]),
			"\"",
		)
		let val = u.trimchar(
			u.trimspaces(config[1]),
			"\"",
		)
		headers[attr] = val
	}
	return [content[end+2:], headers]
}

fn parseHeading(line) {
	if u.startswith(line, "######") {
		return ["h6", [], [u.trimspaces(line[6:])]]
	}
	if u.startswith(line, "#####") {
		return ["h5", [], [u.trimspaces(line[5:])]]
	}
	if u.startswith(line, "####") {
		return ["h4", [], [u.trimspaces(line[4:])]]
	}
	if u.startswith(line, "###") {
		return ["h3", [], [u.trimspaces(line[3:])]]
	}
	if u.startswith(line, "##") {
		return ["h2", [], [u.trimspaces(line[2:])]]
	}
	if u.startswith(line, "#") {
		return ["h1", [], [u.trimspaces(line[1:])]]
	}
	# Empty div
	return ["div", [], [""]]
}

fn asParagraph(content) {
	return ["p", [], [u.join(content, "\n")]]
}

fn processLink(line) {
	# TODO: turn link into anchor
	return line
}

fn parseCodeBlock(content) {
	let lang = u.trimspaces(content[0][3:])
	let code = u.join(content[1:content.length], "\n")
	return ["pre", ["class", "triple-quote " + lang], [code]]
}

fn parseBody(content) {
	let out = []
	for let i = 0; i < content.length; i = i + 1 {
		let line = processLink(content[i])
		if u.startswith(line, "#") {
			out = out + [parseHeading(line)]
		} elif u.startswith(line, "```") {
			let end = u.find(content[i+1:], "```")
			out = out + [
				parseCodeBlock(content[i:i+1+end])
			]
			i = i+1+end
		} else {
			let end = u.findBy(content[i:], fn (l) {
				return u.trimspaces(l) == ""
			})
			if end == -1 {
				end = content.length - i
			}
			out = out + [
				asParagraph(content[i:i+end])
			]
			i = i+end
		}
	}
	return out
}
